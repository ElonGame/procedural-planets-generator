#version 430
[ComputeShader]

#define M_PI 3.1415926535897932384626433832795

uniform sampler2D param_baseHeightMap;


[include internal/include.perlinNoise.glsl]
[include internal/include.worleyNoise.glsl]







// vec2 worley(vec3 P, float jitter, bool manhattanDistance)
// float perlinNoise(vec3 p)

float GetHeightAt(vec3 initialPos)
{
	float result = 0;
	
	{ // base noise
		vec3 pos = initialPos;
		int octaves = 2;
		float freq = 10;
		float ampModifier = 0.05;
		float freqModifier = 15;
		float amp = 1;
		pos *= freq;
		for (int i = 0; i < octaves; i++)
		{
			result += perlinNoise(pos) * amp;
			pos *= freqModifier;
			amp *= ampModifier;
		}
	}
	

	{ // hill tops
		float p = perlinNoise(initialPos * 10);
		if(p > 0) result -= p * 2;
	}
	
	{ // craters

		/*vec2 w = worleyNoise(initialPos*3, 1, false);
		result += smoothstep(0.0, 0.4, w.x) * 10;*/
	}

	return result;

}




uniform float planetRadiusMax;
uniform float planetRadiusVariation;
uniform vec3 offsetFromPlanetCenter;
uniform int numberOfVerticesOnEdge;
uniform vec3 cornerPositionA;
uniform vec3 cornerPositionB;
uniform vec3 cornerPositionC;
uniform int indiciesCount;


 
struct vec2_struct
{
    float x;
    float y;
};
vec2 fromStruct(vec2_struct p)
{
	return vec2(p.x, p.y);
}
vec2_struct toStruct(vec2 p)
{
	vec2_struct s;
	s.x = p.x;
	s.y = p.y;
	return s;
}


struct vec3_struct
{
    float x;
    float y;
    float z;
};
vec3 fromStruct(vec3_struct p)
{
	return vec3(p.x, p.y, p.z);
}
vec3_struct toStruct(vec3 p)
{
	vec3_struct s;
	s.x = p.x;
	s.y = p.y;
	s.z = p.z;
	return s;
}




layout( binding=0 ) buffer buffer1 {
    vec3_struct positions[];
};
layout( binding=1 ) buffer buffer2 {
    vec3_struct normals[];
};
layout( binding=2 ) buffer buffer3 {
    vec2_struct uvs[];
};
layout( binding=3 ) buffer buffer4 {
    int indicies[];
};


layout( local_size_x = 1, local_size_y = 1, local_size_z = 1 ) in;
 


vec3 GetNormal(int a, int b, int c)
{
	vec3 _a = fromStruct(positions[a]);
	vec3 _b = fromStruct(positions[b]);
	vec3 _c = fromStruct(positions[c]);
	return normalize(cross(_b - _a, _c - _a));
}





vec3 calestialToSpherical(vec3 c /*calestial*/)
{
	float r = length(c);
	if (r == 0) return vec3(0);
	return vec3(
		atan(c.z, c.x) / (2 * M_PI) + 0.5,
		asin(c.y / r) / M_PI + 0.5,
		r
	);
}




void main() {
	


	int id = int(gl_GlobalInvocationID.x);
	int tempId = id;
	int ix = 0;
	int iy = 0;
		
	int numberOfVerticesOnLine = 1;
	while(tempId >= numberOfVerticesOnLine && numberOfVerticesOnLine < numberOfVerticesOnEdge)
	{
		tempId -= numberOfVerticesOnLine;
		numberOfVerticesOnLine++;
		iy++;
	}
	ix = tempId;

	float x = 0;
	float y = 0;
	if(numberOfVerticesOnLine > 1) x = float(ix) / (numberOfVerticesOnLine-1);
	if(numberOfVerticesOnEdge > 1) y = float(iy) / (numberOfVerticesOnEdge-1);

	vec3 p = 
		cornerPositionA + 
		(cornerPositionB - cornerPositionA) * y * (1-x) + 
		(cornerPositionC - cornerPositionA) * y * x;

	p = normalize(p);
	vec2 uv = calestialToSpherical(p).xy;

	float height = 0;

	height += texture2D(param_baseHeightMap, uv).r; 
	height += 0.1*GetHeightAt(p);


	p *= planetRadiusMax + planetRadiusVariation * height;
	p -= offsetFromPlanetCenter;

	// DEBUG
	//vec3 p = fromStruct(positions[id]);
	//p.x += 0.01f;

	positions[id] = toStruct(p);
	uvs[id] = toStruct(uv);
}

