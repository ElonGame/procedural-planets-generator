#version 430
[ComputeShader]
[include shaders/include.planet.glsl]
#line 5




 
struct vec2_struct
{
    float x;
    float y;
};
vec2 fromStruct(vec2_struct p)
{
	return vec2(p.x, p.y);
}
vec2_struct toStruct(vec2 p)
{
	vec2_struct s;
	s.x = p.x;
	s.y = p.y;
	return s;
}


struct vec3_struct
{
    float x;
    float y;
    float z;
};
vec3 fromStruct(vec3_struct p)
{
	return vec3(p.x, p.y, p.z);
}
vec3_struct toStruct(vec3 p)
{
	vec3_struct s;
	s.x = p.x;
	s.y = p.y;
	s.z = p.z;
	return s;
}


struct vec4_struct
{
    float x;
    float y;
    float z;
    float w;
};
vec4 fromStruct(vec4_struct p)
{
	return vec4(p.x, p.y, p.z, p.w);
}
vec4_struct toStruct(vec4 p)
{
	vec4_struct s;
	s.x = p.x;
	s.y = p.y;
	s.z = p.z;
	s.w = p.w;
	return s;
}



layout( binding=0 ) buffer buffer0 {
    vec3_struct positions[];
};
layout( binding=1 ) buffer buffer1 {
    vec3_struct normals[];
};
layout( binding=2 ) buffer buffer2 {
    vec2_struct uvs[];
};
layout( binding=3 ) buffer buffer3 {
    int indicies[];
};
layout( binding=4 ) buffer buffer4 {
    vec4_struct out_biomes1[];
};
layout( binding=5 ) buffer buffer5 {
    vec4_struct out_biomes2[];
};


layout( local_size_x = 1, local_size_y = 1, local_size_z = 1 ) in;
 


vec3 GetNormal(int a, int b, int c)
{
	vec3 _a = fromStruct(positions[a]);
	vec3 _b = fromStruct(positions[b]);
	vec3 _c = fromStruct(positions[c]);
	return normalize(cross(_b - _a, _c - _a));
}








uniform dvec3 param_offsetFromPlanetCenter;
uniform int param_numberOfVerticesOnEdge;
uniform dvec3 param_cornerPositionA;
uniform dvec3 param_cornerPositionB;
uniform dvec3 param_cornerPositionC;
uniform int param_indiciesCount;
uniform int param_verticesStartIndexOffset;





// vec2 worley(vec3 P, float jitter, bool manhattanDistance)
// float perlinNoise(vec3 p)

float GetHeightAt(vec3 initialPos)
{
	float result = -0.5;
	
	{ // base noise
		vec3 pos = initialPos;
		int octaves = 8;
		float freq = 400;
		float ampModifier = 0.15;
		float freqModifier = 5;
		float amp = 1;
		pos *= freq;
		for (int i = 0; i < octaves; i++)
		{
			result += perlinNoise(pos) * amp;
			pos *= freqModifier;
			amp *= ampModifier;
		}
	}
	
	/*
	{ // hill tops
		float p = perlinNoise(initialPos * 10);
		if(p > 0) result -= p * 2;
	}
	*/

	/*
	{ // craters

		vec2 w = worleyNoise(initialPos*10, 1, false);
		result += smoothstep(0.0, 0.4, w.x) * 100;
	}
	*/

	return result;

}

double GetHeight(dvec3 direction, vec3 uv)
{
	double height = 0;	

	if(param_baseHeightMapMultiplier > 0) 
		height += param_baseHeightMapMultiplier * texture2D(param_baseHeightMap, uv.xy).r; 
	if(param_noiseMultiplier > 0)			
		height += param_noiseMultiplier * GetHeightAt(vec3(direction * param_radiusMin / 1000000));

	return height;
}

double GetHeight(vec3 uv)
{
	vec3 direction = sphericalToCalestial(uv) ;
	return GetHeight(direction, uv);
}
double GetHeight01(vec3 uv)
{
	return GetHeight(uv) / (param_baseHeightMapMultiplier + param_noiseMultiplier);
}

float GetHumidity(vec3 uvCenter)
{
	const float waterHeight = 0.5;

	vec3 uv = uvCenter;
	if(GetHeight01(uv) < waterHeight) return 1;

	const float maxDistanceToWater = 0.02;
	const float distanceToWaterIncrease = 0.001;
	float distanceToWater = 0;	

	float splits = 3;
	while(distanceToWater < maxDistanceToWater) {

		float angleDelta = 2*M_PI / splits;
		for(float angle = 0; angle < 2*M_PI; angle += angleDelta)
		{
			uv = uvCenter + vec3(
				cos(angle) * distanceToWater,
				sin(angle) * distanceToWater,
				0
			);
			if(GetHeight01(uv) < waterHeight) return 1 - distanceToWater / maxDistanceToWater;
		}
		
		distanceToWater += distanceToWaterIncrease;
		splits += 1;
	}

	return 0;

}


void main() {

	int verticeIndex = int(gl_GlobalInvocationID.x) + param_verticesStartIndexOffset;
	
	vec4 biomes1 = vec4(0);
	vec4 biomes2 = vec4(0);
	
	int tempVerticeIndex = verticeIndex;
	int ix = 0;
	int iy = 0;
		
	int param_numberOfVerticesOnLine = 1;
	while(tempVerticeIndex >= param_numberOfVerticesOnLine && param_numberOfVerticesOnLine < param_numberOfVerticesOnEdge)
	{
		tempVerticeIndex -= param_numberOfVerticesOnLine;
		param_numberOfVerticesOnLine++;
		iy++;
	}
	ix = tempVerticeIndex;

	double x = 0;
	double y = 0;
	if(param_numberOfVerticesOnLine > 1) x = double(ix) / (param_numberOfVerticesOnLine-1);
	if(param_numberOfVerticesOnEdge > 1) y = double(iy) / (param_numberOfVerticesOnEdge-1);

	dvec3 p = 
		param_cornerPositionA + 
		(param_cornerPositionB - param_cornerPositionA) * y * (1-x) + 
		(param_cornerPositionC - param_cornerPositionA) * y * x;

	p = normalize(p);

	vec3 p_vec3 = vec3(p);
	vec3 uv = calestialToSpherical(p_vec3);
	double height = GetHeight(p, uv);

	// passing data to generate biomes in computer shader
	biomes1.x = float(height / (param_baseHeightMapMultiplier + param_noiseMultiplier));
	biomes1.y = GetHumidity(uv);

	p *= param_radiusMin + height;
	p -= param_offsetFromPlanetCenter;

	// DEBUG
	//vec3 p = fromStruct(positions[verticeIndex]);
	//p.x += 0.01f;

	positions[verticeIndex] = toStruct(vec3(p));
	uvs[verticeIndex] = toStruct(uv.xy);
	out_biomes1[verticeIndex] = toStruct(biomes1);
	out_biomes2[verticeIndex] = toStruct(biomes2);

}

