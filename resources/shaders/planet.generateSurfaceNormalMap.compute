#version 430
[ComputeShader]
[include shaders/include.planet.glsl]




 
struct vec2_struct
{
    float x;
    float y;
};
vec2 fromStruct(vec2_struct p)
{
	return vec2(p.x, p.y);
}
vec2_struct toStruct(vec2 p)
{
	vec2_struct s;
	s.x = p.x;
	s.y = p.y;
	return s;
}


struct vec3_struct
{
    float x;
    float y;
    float z;
};
vec3 fromStruct(vec3_struct p)
{
	return vec3(p.x, p.y, p.z);
}
vec3_struct toStruct(vec3 p)
{
	vec3_struct s;
	s.x = p.x;
	s.y = p.y;
	s.z = p.z;
	return s;
}


struct vec4_struct
{
    float x;
    float y;
    float z;
    float w;
};
vec4 fromStruct(vec4_struct p)
{
	return vec4(p.x, p.y, p.z, p.w);
}
vec4_struct toStruct(vec4 p)
{
	vec4_struct s;
	s.x = p.x;
	s.y = p.y;
	s.z = p.z;
	s.w = p.w;
	return s;
}

layout(rgba8, binding = 0) uniform writeonly image2D param_segmentNormalMap;



layout( local_size_x = 16, local_size_y = 16 ) in;
 

uniform dvec3 param_offsetFromPlanetCenter;
uniform int param_numberOfVerticesOnEdge;
uniform dvec3 param_cornerPositionA;
uniform dvec3 param_cornerPositionB;
uniform dvec3 param_cornerPositionC;
uniform int param_indiciesCount;
uniform int param_verticesStartIndexOffset;



void main() {

  
  	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

	vec4 pixel = vec4(0);

 	double x = double(gl_GlobalInvocationID.x)/1024.0;
	double y = double(gl_GlobalInvocationID.y)/1024.0;

	dvec3 positionInterpolated = 
		param_cornerPositionA + 
		(param_cornerPositionB - param_cornerPositionA) * y * (1-x) + 
		(param_cornerPositionC - param_cornerPositionA) * y * x;

	dvec3 dirFromPlanetCenter = normalize(positionInterpolated);

	vec2 spherical = calestialToSpherical(vec3(dirFromPlanetCenter)).xy;

	vec3 normal = (1 + GetProceduralAndBaseHeightMapNormal(spherical, 0.000001)) / 2;

	pixel = vec4(normal, 1);

	//DEBUG
	//pixel=vec4(float(gl_GlobalInvocationID.x)/1024.0, float(gl_GlobalInvocationID.y)/1024.0, 1.0, 1.0);
	imageStore(param_segmentNormalMap, pixel_coords, pixel);
}

